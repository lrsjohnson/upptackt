\chapter{Demonstration}
\label{chap:demo}

My system uses this idea of manipulating diagrams ``in the mind's
eye'' to explore and discover geometry theorems. Before describing its
internal representations and implementation, I will present and
discuss several sample interactions with the system. Further details
details can be found in subsequent chapters.

The overall goal of the system is to emulate a student learning
geometry via an investigative approach. To accomplish this, the system
is divided into four main modules: an imperative construction system,
a perception-based analyzer, a declarative constraint solver, and a
synthesizing learning module.  The following examples will explore
interactions with these modules in increasing complexity, building up
to a full demonstration of the system achieving its learning goals in
Section~\ref{sec:end-goal}.

\section{Imperative Figure Construction}

\enlargethispage*{\baselineskip}

At its foundation, the system provides a language and engine for
performing geometry constructions and building figures.
Example~\ref{basic-fig} presents a simple specification of a
figure. Primitives of points, lines, segments, rays, and circles can
be combined into polygons and figures, and complicated constructions
such as the perpendicular bisector of a segment can be abstracted into
higher-level procedures. The custom special form \texttt{let-geo*}
emulates the standard \texttt{let*} form in Scheme but also annotates
the resulting objects with the names and dependencies as specified in
the construction.

\pagebreak

\begin{code-example}
[label=basic-fig]
{Basic Figure Example}
(define (triangle-with-perp-bisectors)
  (let-geo* ((a (make-point 0 0))
             (b (make-point 1.5 0))
             (c (make-point 1 1))
             (t (polygon-from-points a b c))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))
\end{code-example}

\begin{img-example}
[label=perp-show-figure]
{Rendering the Basic Figure}{images/perpendicular-bisectors.png}
=> (show-figure (triangle-with-perp-bisectors))
\end{img-example}

Given such an imperative description, the system can construct and
display an instance of the figure as shown in
Example~\ref{perp-show-figure}. The graphics system uses the
underlying X window system-based graphics interfaces in MIT Scheme,
labels named points (\texttt{a}, \texttt{b}, \texttt{c}), and
repositions the coordinate system to display interesting features.

In the first figure, the coordinates of the points were explicitly
specified yielding a deterministic instance of the figure. However, to
represent entire spaces of diagram instances, the construction
abstractions support random choices. Example~\ref{random-pb}
demonstrates the creation of a figure involving an arbitrary
triangle.

The second formulation,
\texttt{(simple-random-triangle-perp-bisectors)}, is equivalent to the
first. It displays a syntax extension provided by \texttt{let-geo*}
that shortens the common pattern of accessing and naming the
components of an object. In this case, \texttt{((t (a b c))
    (random-triangle))} will assign to the variable \texttt{t} the
resulting random triangle, and to the variables \texttt{a},
\texttt{b}, and \texttt{c} the resulting triangle's vertices.

\begin{pdf-example}
[label=random-pb]
{Introducing Randomness}
{images/random-pb.pdf}
(define (random-triangle-perp-bisectors)
  (let-geo* ((t (random-triangle))
             (a (polygon-point-ref t 0))
             (b (polygon-point-ref t 1))
             (c (polygon-point-ref t 2))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))

(define (simple-random-triangle-perp-bisectors)
  (let-geo* (((t (a b c)) (random-triangle))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))
\end{pdf-example}

As examples of more involved constructions, Examples
\ref{angle-bisector-distance} and \ref{incircle-circumcircle-fig}
demonstrate working with other objects (angles, rays, circles) and
construction procedures. Notice that, in the angle bisector example,
the pattern matching syntax extracts the components of an angle (ray,
vertex, ray) and segment (endpoints), and that in the
Inscribed/Circumscribed example, some intermediary elements are
omitted from the final figure list and will not be displayed or
analyzed.

\begin{pdf-example}
[label=angle-bisector-distance]
{Angle Bisector Distance}
{images/angle-bisector-distance.pdf}
(define (angle-bisector-distance)
  (let-geo* (((a (r-1 v r-2)) (random-angle))
             (ab (angle-bisector a))
             (p (random-point-on-ray ab))
             ((s-1 (p b)) (perpendicular-to r-1 p))
             ((s-2 (p c)) (perpendicular-to r-2 p)))
     (figure a r-1 r-2 ab p s-1 s-2)))

=> (show-figure (angle-bisector-distance))
\end{pdf-example}

\enlargethispage*{-\baselineskip}

\begin{pdf-example}
[label=incircle-circumcircle-fig,
break at=8.5cm]
{Inscribed and Circumscribed Circles}
{images/incenter-circumcenter.pdf}
(define (inscribed-circumscribed)
  (let-geo* (((t (a b c)) (random-triangle))
             (((a-1 a-2 a-3)) (polygon-angles t))
             (ab1 (angle-bisector a-1))
             (ab2 (angle-bisector a-2))
             ((radius-segment (center-point radius-point))
              (perpendicular-to (make-segment a b)
                                (intersect-linear-elements ab1 ab2)))
             (ins-circle (circle-from-points center-point radius-point))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb-center (intersect-lines pb1 pb2))
             (circum-circle (circle-from-points pb-center a)))
    (figure t a-1 a-2 a-3 pb-center radius-segment
            ins-circle circum-circle)))

=> (show-figure (inscribed-circumscribed))
\end{pdf-example}

The sample images shown alongside these constructions represent images
from separate executions of the figure. An additional method for
viewing and displaying involves ``running an animation'' of these
constructions in which several instances of the figure are created and
displayed, incrementally wiggling each random choice. In generating
and wiggling the random values, some effort is taken to avoid
degenerate cases or instances where points are too close to one
another, as such cases can lead to undesirable floating-point errors
in the numerical analysis.

\section{Perception and Observation}

Given the imperative construction module that enables the
specification and construction of geometry figures, the second module
focuses on perception and extracting interesting observations from
these figures.

Example \ref{simple-analysis} demonstrates the interface for obtaining
observations from a figure. An observation is a structure that
associates a relationship (concurrent, equal length, parallel) with
objects in the figure that satisfy the relationship. Relationships are
represented as predicates over typed n-tuples and are checked against
all such n-tuples found in the figure under analysis. For example, the
perpendicular relationship is checked against all pairs of linear elements
in the figure.

The observation objects returned are compound structures that maintain
properties of the underlying relationships and references to the
original objects under consideration. Dependency information about how
these original objects were construction will be later used to
generalize these observations into conjectures. For now, my custom
printer \texttt{print-observations} can use the name information of
the objects to display the observations in a more human-readable
format.

\begin{repl-example}
[label=simple-analysis]
{Simple Analysis}
=> (all-observations (triangle-with-perp-bisectors))

(#[observation 77] #[observation 78] #[observation 79] #[observation 80])

=> (print-observations (all-observations (triangle-with-perp-bisectors)))

((concurrent pb1 pb2 pb3)
 (perpendicular pb1 (segment a b))
 (perpendicular pb2 (segment b c))
 (perpendicular pb3 (segment c a)))
\end{repl-example}

The fact that the perpendicular bisector of a segment is perpendicular
to that segment is not very interesting. Thus, as shown in Example
\ref{interesting-analysis}, the analysis module also provides an
interface for reporting only the interesting observations. Currently,
information about the interesting relationships formed by a
construction operation such as perpendicular bisector is specified
alongside instructions for how to perform the operation, but a further
extension of the learning module could try to infer inductively which
properties result from various known operations.

\begin{repl-example}
[label=interesting-analysis]
{Interesting Analysis}
=> (print-observations (interesting-observations
                         (triangle-with-perp-bisectors)))

((concurrent pb1 pb2 pb3))
\end{repl-example}

For an example with more relationships, Example
\ref{parallelogram-analysis} demonstrates the observations and
relationships found in a figure with a random parallelogram. These
analysis results will be used again later when I demonstrate the
system learning definitions for polygons and simplifying such
definitions to minimal sufficient constraint sets. Note that although
the segments, angles, and points were not explicitly listed in the
figure, they are extracted from the polygon that is listed. Extensions
to the observation model can extract additional points and segments
not explicitly listed in the original figure.

\begin{repl-example}
[label=parallelogram-analysis]
{Parallelogram Analysis}
(define (parallelogram-figure)
  (let-geo* (((p (a b c d)) (random-parallelogram)))
    (figure p)))

=> (pprint (all-observations (parallelogram-figure)))

((equal-length (segment a b) (segment c d))
 (equal-length (segment b c) (segment d a))
 (equal-angle (angle a) (angle c))
 (equal-angle (angle b) (angle d))
 (supplementary (angle a) (angle b))
 (supplementary (angle a) (angle d))
 (supplementary (angle b) (angle c))
 (supplementary (angle c) (angle d))
 (parallel (segment a b) (segment c d))
 (parallel (segment b c) (segment d a)))
\end{repl-example}

\texttt{all-observations} will report all reasonable observations
found, but as will be shown in Section~\ref{sec:end-goal}, as the
system learns new terms and concepts, a request for
\texttt{interesting-observations} will use such learn concepts to
eliminate redundant observations and filter out previously-discovered
facts. In this case, once a definition for parallelogram is learned,
\texttt{interesting-observations} would simply report that \texttt{p}
is a parallelogram and omit observations implied by that fact.


\section{Mechanism-based Declarative Constraint Solver}

The first two modules focus on performing imperative constructions to
build diagrams and analyze them to obtain interesting symbolic
observations and relationships. Alone, these modules could assist a
mathematician in building, analyzing, and exploring geometry
concepts.

However, an important aspect of automating learning theorems and
definitions involves reversing this process and obtaining instances of
diagrams by solving provided symbolic constraints and
relationships. When we are told to ``Imagine a triangle ABC in which
AB = BC'', we visualize in our mind's eye an instance of such a
triangle before continuing with the instructions.

Thus, the third module is a declarative constraint solver. To model
the physical concept of building and wiggling components until
constraints are satisfied, the system is formulated around solving
mechanisms built from bars and joints that must satisfy certain
constraints. Such constraint solving is implemented by extending the
Propagator Model created by Alexey Radul and Gerald Jay Sussman
\cite{gjs-propagator} to handle partial information and constraints
about geometry positions. Chapter~\ref{chap:declarative} discusses
further implementation details.

\subsection{Bars and Joints}

Example~\ref{simple-mechanism} demonstrates the specification of a
very simple mechanism. Unlike the sequential, Scheme variable based
\texttt{let-geo*} specification of constructions in the imperative
construction system, to specify mechanisms, \texttt{m:mechanism} is
applied to a list of linkage and constraint declarations containing
symbolic identifiers.  This example mechanism is composed of two bar
linkages with one joint linkage between the bars, along with a
constraint that the joint is a right angle.

\begin{code-example}
[label=simple-mechanism]
{Very Simple Mechanism}
(define (simple-mechanism)
  (m:mechanism
   (m:make-named-bar 'a 'b)
   (m:make-named-bar 'b 'c)
   (m:make-named-joint 'a 'b 'c)
   (m:c-right-angle (m:joint 'b))))
\end{code-example}

Assembling a mechanism involves first adjoining the bars and joints
together so that the named points are identified with one another.
Initially, each bar has unknown length and direction, each joint has
an unknown angle, and each endpoint has unknown position. Constraints
for the bar and joint properties are then introduced alongside any
explicitly specified constraints.

Solving a mechanism involves repeatedly selecting position, lengths,
angles, and directions that are not fully specified and selecting
values within the domain of that element's current partial
information. As values are specified, the wiring of the propagator
model propagates further partial information to other values.

The printed statements in Example \ref{solving-simple-mechanism}
demonstrate that solving the simple mechanism above involves
specifying the location of point \texttt{a}, then specifying the
length of bar \texttt{a-b} and the direction from \texttt{a} that the
bar extends. After those specifications, the joint angle is
constrained to be a right angle and the location of point \texttt{b}
is known by propagating information about point \texttt{a} and bar
\texttt{a-b}'s position and length. Thus, point \texttt{c} is known to
be on a ray extending outwards from \texttt{b} and the only remaining
property needed to fully specify the figure is the length of bar
\texttt{b-c}. The command \texttt{m:run-mechanism} builds and solves
the mechanism, then converts the result into an analytic figure and
displays it.

\begin{pdf-example}
[label=solving-simple-mechanism]
{Solving the Very Simple Mechanism}
{images/simple-mechanism.pdf}
=> (m:run-mechanism simple-mechanism)

(initializing-point m:bar:a:b-p1 (0 0))
(specifying-bar-length m:bar:a:b .5644024854677596)
(initializing-direction m:bar:a:b-dir (direction 4.999857164003272))
(specifying-bar-length m:bar:b:c 1.1507815910257295)
\end{pdf-example}

\subsection{Geometry Examples}

These bar and linkage mechanisms can be used to represent the
topologies of several geometry figures. Bars correspond to segments
and joints correspond to angles. Example \ref{arbitrary-tri}
demonstrates the set of linkages necessary to specify the topology of
a triangle. The second formulation,
\texttt{(simpler-arbitrary-triangle)} is equivalent to the first since
the utility procedure \texttt{m:establish-polygon-topology} expands to
create the set of $n$ bars and $n$ joint specifications needed to
represent a closed polygon for the given $n$ vertex names.

\begin{code-example}
[label=arbitrary-tri]
{Describing an Arbitrary Triangle}
(define (arbitrary-triangle)
  (m:mechanism
   (m:make-named-bar 'a 'b)
   (m:make-named-bar 'b 'c)
   (m:make-named-bar 'c 'a)
   (m:make-named-joint 'a 'b 'c)
   (m:make-named-joint 'b 'c 'a)
   (m:make-named-joint 'c 'a 'b)))

(define (simpler-arbitrary-triangle)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c)))
\end{code-example}

As seen in Example~\ref{run-arbitrary-tri} (next page), once joints
\texttt{b} and \texttt{c} have had their angles specified, propagation
fully determines the angle of joint \texttt{a}.  The only parameter
remaining is the length of one of the bars.  The two
\texttt{initializing-} steps don't affect the resulting shape but
determine its position and orientation on the canvas.

In this case, joint angles are specified first. The ordering of what
is specified is guided by a heuristic that helps all of the examples
shown in this chapter converge to solutions. The heuristic generally
prefers specifying the most constrained values first. However, in some
scenarios, specifying values in the wrong order can yield premature
contradictions. A planned extension will attempt to recover from such
situations more gracefully by trying other orderings for specifying
components.

\begin{pdf-example}
[label=run-arbitrary-tri]
{Solving the Triangle}{images/arbitrary-triangle.pdf}
=> (m:run-mechanism (arbitrary-triangle))

(specifying-joint-angle m:joint:c:b:a .41203408293499)
(initializing-direction m:joint:c:b:a-dir-1 (direction 3.888926311421853))
(specifying-joint-angle m:joint:a:c:b 1.8745808264593105)
(initializing-point m:bar:c:a-p1 (0 0))
(specifying-bar-length m:bar:c:a .4027149730292784)
\end{pdf-example}

To include some user-specified constraints, Example~\ref{solve-i-t}
shows the steps involved in solving an isoceles triangle from the fact
that its base angles are congruent. Notice that the only two values
that must be specified are one joint angle and one bar length. The
rest is handled by propagation.

Propagation involves representing the partial information of where
points and angles can be. A specified angle constrains a point to a
ray and a specified length constrains a point to be on an arc of a
circle. As information about a point is merged from several sources,
intersecting these rays and circles yields unique solutions for where
the points must exist. Then, as the location of points are determined,
the bidirectional propagation continues to update the corresponding
bar lengths and joint angles Although not as dynamic, these
representations correspond to physically wiggling and extending the
bars until they reach one another.

\begin{pdf-example}
[label=solve-i-t]
{Constraint Solving for Isoceles Triangle}
{images/isoceles.pdf}
(define (isoceles-triangle-by-angles)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c)
   (m:c-angle-equal (m:joint 'a)
                    (m:joint 'b))))

=> (m:run-mechanism  isoceles-triangle-by-angles)

(specifying-joint-angle m:joint:c:b:a .6219719886662947)
(initializing-direction m:joint:c:b:a-dir-1 (direction .9330664240883363))
(initializing-point m:bar:b:c-p1 (0 0))
(specifying-bar-length m:bar:b:c .3557699722973674)
\end{pdf-example}

Example~\ref{pl-by-angles} continues the analysis of properties of the
parallelogram. In this case, the constraint solver is able to build
figures given the fact that its opposite angles are equal. The fact
that these all happen to be parallelograms will be used by the
learning module to produce a simpler definition for a parallelogram.

\begin{pdf-example}
[label=pl-by-angles]
{Constraint Solving for Parallelogram}
{images/parallelogram.pdf}
(define (parallelogram-by-angles)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c 'd)
   (m:c-angle-equal (m:joint 'a)
                    (m:joint 'c))
   (m:c-angle-equal (m:joint 'b)
                    (m:joint 'd))))

=> (m:run-mechanism parallelogram-by-angles)

(specifying-joint-angle m:joint:c:b:a 1.6835699856637936)
(initializing-angle m:joint:c:b:a-dir-1 (direction 1.3978162819212452))
(initializing-point m:bar:a:b-p1 (0 0))
(specifying-bar-length m:bar:a:b .8152792207652096)
(specifying-bar-length m:bar:b:c .42887899934327023)
\end{pdf-example}

To demonstrate the constraint solving working on a more complicated
example, Example~\ref{is-rect-2} represents the constraints from the
middle ``Is this a rectangle?'' question from Chapter
\ref{chap:motivation}. This question asks whether a quadrilateral in
which a pair of opposite sides are congruent, a pair of opposite
angles are congruent, and one of the other angles is a right angle is
always a rectangle. Try working this constraint problem by hand or in
your mind's eye.

\begin{code-example}
[label=is-rect-2]
{Rectangle Constraints Example}
(define (is-this-a-rectangle-2)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c 'd)
   (m:c-length-equal (m:bar 'a 'd) (m:bar 'b 'c))
   (m:c-right-angle (m:joint 'd))
   (m:c-angle-equal (m:joint 'a) (m:joint 'c))))
\end{code-example}

As seen in Example~\ref{solve-rect}, solutions are not all
rectangles.  Chapter~\ref{chap:declarative} includes a more detailed
walkthrough of how this example is solved. Interestingly, once the
initial scale is determined by the first bar length, the remaining
shape only has one degree of freedom.

\begin{pdf-example}
[label=solve-rect]
{Solved Constraints}{images/rect-demo.pdf}
=> (m:run-mechanism (is-this-a-rectangle-2))

(specifying-bar-length m:bar:d:a .6742252545577186)
(initializing-direction m:bar:d:a-dir (direction 4.382829365403101))
(initializing-point m:bar:d:a-p1 (0 0))
(specifying-joint-angle m:joint:c:b:a 2.65583669872538)
\end{pdf-example}

As a final mechanism example, in addition to solving constraints of
the angles and sides for a \emph{single} polygon, the mechanism system
can support the creation of arbitrary topologies of bars and
joints. In the following examples, by using several calls to the
\texttt{establish-polygon-topology utility}, I build the topology of a
quadrilaterals whose diagonals intersect at a point \texttt{e} and
explore the effects of various constraints on these diagonal
segments. \texttt{m:quadrilateral-with-intersecting-diagonals} will
simplify specification of this topology in the following examples.

\begin{code-example}
[label=quad-diagonals]
{More Involved Topologies for Constraint Solving}
(define (m:quadrilateral-with-intersecting-diagonals a b c d e)
  (list (m:establish-polygon-topology a b e)
        (m:establish-polygon-topology b c e)
        (m:establish-polygon-topology c d e)
        (m:establish-polygon-topology d a e)
        (m:c-line-order c e a)
        (m:c-line-order b e d)))
\end{code-example}

\begin{pdf-example}
[label=kite-from-diag,
comment style={frame hidden,
opacityback=0,
height=5.6cm,
raster columns=2,graphics pages={1,2}}]
{Kites from Diagonal Properties}
{images/kite-diag.pdf}
(define (kite-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-right-angle (m:joint 'b 'e 'c)) ;; Right Angle in Center
   (m:c-length-equal (m:bar 'c 'e) (m:bar 'a 'e))))

=> (m:run-mechanism kite-from-diagonals)
\end{pdf-example}

\begin{pdf-example}
[label=it-from-diag,
comment style={frame hidden,
opacityback=0,
height=5.6cm,
raster columns=2,graphics pages={1,2}}]
{Isoceles Trapezoids from Diagonals}
{images/it-diag.pdf}
(define (isoceles-trapezoid-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-length-equal (m:bar 'a 'e) (m:bar 'b 'e))
   (m:c-length-equal (m:bar 'c 'e) (m:bar 'd 'e))))

=> (m:run-mechanism isoceles-trapezoid-from-diagonals)
\end{pdf-example}

\begin{pdf-example}
[label=pl-from-diag,
comment style={frame hidden,
opacityback=0,
height=5.6cm,
raster columns=2,graphics pages={1,2}}]
{Parallelograms from Diagonal Properties}
{images/pl-diag.pdf}
(define (parallelogram-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-length-equal (m:bar 'a 'e) (m:bar 'c 'e))
   (m:c-length-equal (m:bar 'b 'e) (m:bar 'd 'e))))
\end{pdf-example}

As seen in Examples~\ref{kite-from-diag} through~\ref{pl-from-diag},
simple specifications on the diagonals of a quadrilateral can fully
constrain such quadrilaterals to particular classes.  Such results
are interesting to be able to explore via this module alone, but also
becomes a powerful tool as the learning module combines imperative and
declarative information.

\enlargethispage*{\baselineskip}

\section{Learning Module}
\label{sec:end-goal}

The previous sections described modules for performing constructions,
observing interesting symbolic relationships, and rebuilding figures
that satisfy such relationships. As the final module, the learning
module interfaces with these modules to achieve the end goal of
emulating a student learning geometry via an investigative approach.

Although we have seen examples of various higher-level terms and
objects, the learning module begins with very limited knowledge about
geometry. The lattice in Example~\ref{initial-lattice} represents the
built-in objects the system understands. Although it has some
knowledge of points, segments, lines, rays, angles, circles and
polygons, upon startup, it knows nothing about higher-level terms such
as trapezoids, parallelograms, or isoceles triangles.

\begin{img-example}
[label=initial-lattice,
breakable=false]
{Initial Lattice}{images/initial-lattice.png}
=> (what-is 'trapezoid)
unknown

=> (what-is 'line)
primitive-definition

=> (what-is 'triangle)
(triangle (polygon)
          ((n-sides-3 identity)))

=> (show-definition-lattice)
\end{img-example}

A user representing a ``teacher'' can interact with the system by
creating investigations using these primitives. These investigations
are typically steps to construct a diagram instance, but can include
other specifications. The system will construct and examine the figure
resulting from such investigations, and sometimes perform related
investigations of its own. Interesting relationships invariant across
the instances are generalized into new concepts and theorems. To
evaluate the system's learning, the system provides means for a user
to query its knowledge or apply it to new situations.

One example of this process involves the ``teacher'' user crafting an
investigation procedure that creates instances of a new class of
object. For instance, a user could define \texttt{random-trapezoid} to
be a procedure that, each time it is called, returns randomly
constructed trapezoid. Example~\ref{rand-trp} shows the full range of
trapezoids created via the \texttt{random-trapezoid} procedure.

\begin{pdf-example}
[label=rand-trp,
comment style={frame hidden,opacityback=0,
raster columns=3,graphics pages={1,2,3}}]
{Random Figures}{images/rand-trp.pdf}
=> (show-element (random-trapezoid))
\end{pdf-example}

The learning module can interface with the perception module to obtain
observations about given element. In Example \ref{analyze-trapezoid},
the results show the full dependencies of elements under consideration
instead of their names. These dependency structures are later used to
convert the observations about this specific trapezoid into general
conjectures that can be tested against other polygons.

\begin{repl-example}
[label=analyze-trapezoid]
{Analyzing an Element}
=> (pprint (analyze-element (random-trapezoid)))

((supplementary (polygon-angle 0 <premise>) (polygon-angle 3 <premise>))
 (supplementary (polygon-angle 1 <premise>) (polygon-angle 2 <premise>))
 (parallel (polygon-segment 0 1 <premise>) (polygon-segment 2 3 <premise>)))
\end{repl-example}

With these analysis abilities, a user can teach the system new object
classes by providing a term (\texttt{'trapezoid}) and a generator
procedure that produces instances of that element as seen in
Example~\ref{learn-terms}.

\begin{repl-example}
[label=learn-terms]
{Learning New Terms}
=> (learn-term 'parallelogram random-parallelogram)
done

=> (learn-term 'trapezoid random-trapezoid)
done
\end{repl-example}

Although the internal implementations of user-provided generator
procedures are opaque to the learning module, it is able to examine
interesting relationships invariant across instances of such objects
and discover properties for the new definition.

As shown in example \ref{what-is}, after being instructed to learn
what a parallelogram is from the \texttt{random-parallelogram}
procedure, when queried for a definition, we're given the term, the
base classifications of the element, and all properties known to be
true of such objects.

\begin{repl-example}
[label=what-is]
{Asking about Terms}
=> (what-is 'parallelogram)
(parallelogram
 (quadrilateral)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 2 3 <premise>))
  (equal-length (polygon-segment 1 2 <premise>)
                (polygon-segment 3 0 <premise>))
  (equal-angle (polygon-angle 0 <premise>)
               (polygon-angle 2 <premise>))
  (equal-angle (polygon-angle 1 <premise>)
               (polygon-angle 3 <premise>))
  (supplementary (polygon-angle 0 <premise>)
                 (polygon-angle 1 <premise>))
  (supplementary (polygon-angle 0 <premise>)
                 (polygon-angle 3 <premise>))
  (supplementary (polygon-angle 1 <premise>)
                 (polygon-angle 2 <premise>))
  (supplementary (polygon-angle 2 <premise>)
                 (polygon-angle 3 <premise>))
  (parallel (polygon-segment 0 1 <premise>)
            (polygon-segment 2 3 <premise>))
  (parallel (polygon-segment 1 2 <premise>)
            (polygon-segment 3 0 <premise>))))
\end{repl-example}


To use such learned knowledge, we can use \texttt{is-a?} to test
whether other elements are satisfy the known definition of a term. As
shown in example \ref{test-def}, results are correctly returned for
any polygon that satisfies the observed properties. In cases where the
properties are not satisfied, the system reports the failed
conjectures or classifications (e.g. an equaliteral triangle is not a
parallelogram: It failed the necessary classification that it must be
a quadrilateral because it didn't have 4 sides).

\begin{repl-example}
[label=test-def]
{Testing Definitions}
=> (is-a? 'parallelogram (random-parallelogram))
#t

=> (is-a? 'parallelogram (random-rectangle))
#t

=> (is-a? 'parallelogram (polygon-from-points
                (make-point 0 0)
                (make-point 1 0)
                (make-point 2 1)
                (make-point 1 1)))
#t

=> (is-a? 'parallelogram (random-trapezoid))
(failed-conjecture
 (equal-length (polygon-segment 0 1 <premise>)
               (polygon-segment 2 3 <premise>)))

=> (is-a? 'parallelogram (random-equilateral-triangle))
(failed-conjecture (n-sides-4 <premise>))
(failed-classification quadrilateral)

=> (is-a? 'parallelogram (random-segment))
(failed-classification polygon)
(failed-classification quadrilateral)
\end{repl-example}

Learning individual definitions is nice, but cool properties arise
when definitions build upon one another. When a new term is learned,
the system checks other related terms for overlapping properties to
determine where the new definition fits in the current lattice of
terms. In Example~\ref{build-def}, we see that, after learning
definitions of kites and rhombuses, the reported definition of a
rhombus is that it a parallelogram and kite that satisfies two
additional rhombus-specific properties about equal length
sides. Later, after learning about rectangles, amazingly, the system
shows us that the definition of a square has no additional properties
beyond that of being both a rhombus and a rectangle. The system is
able to make these same deductions and update definitions irrespective
of the order in which it is taught the terms.

\begin{repl-example}
[label=build-def]
{Building on Definitions}
=> (learn-term 'rhombus random-rhombus)
=> (learn-term 'kite random-kite)
=> (what-is 'rhombus)
(rhombus
 (parallelogram kite)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 3 0 <premise>))
  (equal-length (polygon-segment 1 2 <premise>)
                (polygon-segment 2 3 <premise>))))

=> (learn-term 'rectangle random-rectangle)
=> (learn-term 'square random-square)
=> (what-is 'square)
(square (rhombus rectangle) ())
\end{repl-example}

As it learns definitions, the system constructs and maintains a
lattice of known concepts in which child nodes are more specific
classes of their parents. An example of the definition lattice the
system generated after learning several more terms is shown in
Example~\ref{full-lattice}. We see that the accurate relations are
expressed:

\begin{img-example}
[label=full-lattice,
breakable=false,
comment style={size=fbox,frame hidden,height=8.5cm}]
{Expanded Definition Lattice}{images/polygon-lattice.png}
=> (show-definition-sublattice 'polygon)
\end{img-example}

Although most terms can be distinguished from one another using the
basic angle and side properties, in some cases the initial analysis of
the polygon is insufficient. As seen in Example~\ref{learn-ortho},
when initially learning the orthodiagonal term, the system was not
able to observe any differentiating properties between arbitrary
quadrilaterals and orthodiagonal quadrilaterals. Orthodiagonal
quadrilaterals are quadrilaterals with the property that their
diagonals are perpendicular to one another.

\begin{repl-example}
[label=learn-ortho]
{Learning Orthodiagonal Quadrilaterals}
=> (learn-term 'orthodiagonal random-orthodiagonal-quadrilateral)
"Warning: No new known properties for term: orthodiagonal. Appears same as quadrilateral."
done

\end{repl-example}

To handle such situations and to enable the learning module to capture
more general theorems about its objects, the system allows users to
specify investigations based on a premise. These investigations
represent the English instructions of \emph{``Given \texttt{<premise
    objects>}, construct \texttt{<secondary constructions>}. Notice
  anything interesting?''}. They are structured extremely similarly to
imperative figures, but use a ``dependency injected'' premise argument
to enable the learning module to control what is being investigated.
By conditioning such constructions and analysis on the premise
objects, the learning module is able to filter out observations based
on previously-learned theorems and store new observations as theorems
for future use.

The investigation in Example~\ref{diag-investigation} takes a
quadrilateral as its premise and constructs a figure including the
quadrilateral's diagonals.

\begin{code-example}
[label=diag-investigation]
{Diagonals Investigation}
(define diagonal-investigation
  (make-investigation
   'quadrilateral
   (lambda (premise)
     (let-geo*
         ((((a b c d)) premise)
          (diag-1 (make-segment a c))
          (diag-2 (make-segment b d)))
       (figure premise diag-1 diag-2)))))
\end{code-example}

Investigations can be run either for a particular premise term or for
an entire sublattice of descendants.

\begin{repl-example}
[label=run-investigation]
{Performing Investigations}
=> (run-investigation-for-term diagonal-investigation 'equidiagonal)
((equal-length diag-1 diag-2))

=> (run-investigation-for-term diagonal-investigation 'orthodiagonal)
((perpendicular diag-1 diag-2))
\end{repl-example}

In addition to displaying the interesting new results the
investigation yields, such properties are added to original structures
of the premise objects to be checked in the future. In the
orthodiagonal and equidiagonal cases, this investigation correctly
identifies and adds properties regarding the diagonals and places the
terms in their rightful place in the lattice.

Running investigations on entire subtrees of related terms can often
provide interesting information about where in the lattice particular
properties change. Example~\ref{run-consecutive} shows selected output
from running a consecutive midpoint investigation that builds a inner
quadrilateral from the midpoints of the sides of the given
quadrilateral.

\begin{repl-example}
[label=run-consecutive]
{Consecutive Midpoint Investigation \protect\newline[Selected Output]}
=> (run-investigation consecutive-midpoints-investigation)
(investigating quadrilateral)
   ((parallelogram inner-polygon))

(investigating equidiagonal)
   ((rhombus inner-polygon))

(investigating orthodiagonal)
   ((rectangle inner-polygon))

(investigating square)
   ((square inner-polygon))
...
\end{repl-example}

Interestingly, these results show that in any outer
quadrilateral, the inner quadrilateral is a parallelogram, that the
inner polygon for any equidiagonal quadrilateral is a rhombus, and the
inner polygon for any orthodiagonal quadrilateral is a
rectangle. Then, as matched by looking back to the full lattice in
Example~\ref{full-lattice}, the inner quadrilateral of a square (most
general descendent of equidiagonal and orthodiagonal) is also a square
(the most general descendent of rhombus and rectangle).

Thus, Investigation structures can represent broader explorations for the
system to perform.  Although not yet implemented, a similar process
using a multi-element premise structure could explore relationships
yielded by a applying a construction procedure to its arguments where
each of its arguments satisfies a separate premise.

\section{Final Example: Simplifying Definitions}

As properties accumulate from analysis and investigation, the
need to satisfy all known properties overconstraints the resulting
definitions. For example, satisfying some small subset of the known
properties of a parallelogram is sufficient to determine whether an
unknown object is a parallelogram without checking every property
known about parallelograms.

Accordingly, the final, fun example that integrates all of these
systems is the process of learning simpler definitions for geometry
terms. In these examples, the procedure
\texttt{get-simple-definitions} takes a known term, looks up the known
observations and properties for that term, and tests all reasonable
subsets of those properties as constraints using the constraint
solver. For each subset of properties, if the constraint solver was
able to create a diagram satisfying exactly those properties, the
resulting diagram is examined as with the original \texttt{is-a?}
procedure to see if all the known properties of the original term
hold.

If so, the subset of properties is reported as a sufficient definition
of the term, and if the resulting diagram fails some properties, the
subset is reported as an insufficient set of constraints. These
resulting valid definitions can be treated as equivalent, simpler
definitions and used as the premises in new theorems about the
objects.

In Examples \ref{simple-definitions} and~\ref{pl-definitions}, we see
a trace of finding simple definitions for isoceles triangles and
parallelograms. In the first example, the observed properties of an
isoceles triangle are that its base segments and angles are equal. After
the definition simplification via constraint solving, we actually
discover that the single constraints of a pair of congruent base
angles or a pair of congruent sides are sufficient.

\begin{repl-example}
[label=simple-definitions]
{Learning Simple Definitions}
=> (what-is 'isoceles-triangle)

(i-t
 (triangle)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 2 0 <premise>))
  (equal-angle (polygon-angle 1 <premise>) (polygon-angle 2 <premise>))))

=> (get-simple-definitions 'isoceles-triangle)

((sufficient
  (((equal-angle (*angle* b) (*angle* c)))
   ((equal-length (*segment* a b) (*segment* c a)))))
 (insufficient (()))
 (unknown ()))
\end{repl-example}

In the parallelogram Example \ref{pl-definitions}, some subsets are
marked as unknown because the constraint solver wasn't able to solve a diagram
given those constraints. However, the results still show some
interesting valid definitions such as the pair of equal opposite
angles as explored in Example~\ref{pl-by-angles} or equal length
opposite sides and correctly mark several sets of insufficient
definitions as not being specific enough.

\begin{repl-example}
[label=pl-definitions]
{Learning Simple Parallelogram Definitions}
=> (get-simple-definitions 'parallelogram)

((sufficient
  (((equal-length (*segment* a b) (*segment* c d))
    (equal-length (*segment* b c) (*segment* d a)))
   ((equal-angle (*angle* a) (*angle* c))
    (equal-angle (*angle* b) (*angle* d)))))
 (insufficient
  (((equal-length (*segment* a b) (*segment* c d))
    (equal-angle (*angle* b) (*angle* d)))))
 (unknown
  (((equal-angle (*angle* a) (*angle* c)))
   ((equal-length (*segment* b c) (*segment* d a))))))
\end{repl-example}

This simple definitions implementation is still a work in progress and
has room for improvement. In the future I plan to use the knowledge
about what properties the insufficient diagram is violating to use as
a possible addition to the constraint set. Further extensions could
also involve generalizing this get-simple-definitions to support other
topologies for the initial properties (such as the quadrilaterals
being fully specified by their diagonal properties as in
Example~\ref{quad-diagonals}).

Given this framework of use cases for the modules, the remaining
chapters will discuss further representation and implementation
details.
