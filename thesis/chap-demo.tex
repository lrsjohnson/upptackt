\chapter{Demonstration}
\label{chap:demo}

My system uses this idea of manipulating diagrams ``in the mind's
eye'' to explore and discover geometry theorems. Before describing its
internal representations and modules, I will present and discuss
several sample interactions with the system. Further implementation
details can be found in subsequent chapters.

The system is divided into four main modules: an imperative
construction system, a perception-based analyzer, a declarative
constraint solver, and a synthesizing learning module. The following
examples explore interactions with these modules in increasing
complexity.

\section{Imperative Figure Construction}

At its foundation, the system provides a language and engine for
performing geometry constructions and building figures.

Example~\ref{basic-fig} presents a simple specification of a
figure. Primitives of points, lines, segments, rays, and circles can
be combined into polygons and figures and complicated constructions
such as the perpendicular bisector of a segment can be abstracted into
higher-level construction procedures. The custom special form
\texttt{let-geo*} emulates the standard \texttt{let*} form in Scheme
but also annotates the resulting objects with the names and
dependencies as specified in this construction.

\begin{code-example}
[label=basic-fig]
{Basic Figure Example}
(define (triangle-with-perp-bisectors)
  (let-geo* ((a (make-point 0 0))
             (b (make-point 1.5 0))
             (c (make-point 1 1))
             (t (polygon-from-points a b c))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))
\end{code-example}

Given such an imperative description of a figure, the system can
construct and display an instance of the figure as shown in
Example~\ref{perp-show-figure}. The graphics system uses the
underlying X window system-based graphics interfaces in MIT Scheme,
labels named points (a, b, c), and repositions the coordinate system
to display interesting features.

\begin{img-example}
[label=perp-show-figure]
{Rendering the Basic Figure}{images/perpendicular-bisectors.png}
=> (show-figure (triangle-with-perp-bisectors))
\end{img-example}

In the first figure, the coordinates of the point were explicitly
specified yielding a deterministic instance of the figure. However, as
geometry figures often involve arbitrary choices, the construction
abstractions support random choices. Figure~\ref{random-pb}
demonstrates the creation of a figure involving an arbitrary
triangle. The second formulation
\texttt{(simple-random-triangle-with-perp-bisectors)} displays a
syntax extension provided by \texttt{let-geo*} that shortens the
common pattern of accessing and naming the components of a random
object.

\begin{pdf-example}
[label=random-pb]
{Introducing Randomness}
{images/random-pb.pdf}
(define (random-triangle-with-perp-bisectors)
  (let-geo* ((t (random-triangle))
             (a (polygon-point-ref t 0))
             (b (polygon-point-ref t 1))
             (c (polygon-point-ref t 2))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))

(define (simple-random-triangle-with-perp-bisectors)
  (let-geo* (((t (a b c)) (random-triangle))
             (pb1 (perpendicular-bisector (make-segment a b)))
             (pb2 (perpendicular-bisector (make-segment b c)))
             (pb3 (perpendicular-bisector (make-segment c a))))
    (figure t pb1 pb2 pb3)))
\end{pdf-example}

Finally, as examples of more involved constructions, Examples
\ref{angle-bisector-distance} and \ref{incircle-circumcircle-fig}
demonstrate working with other objects (angles, rays, circles) and
construction procedures. Notice that in the angle bisector example
the pattern matching syntax extracts the components of an angle (ray,
vertex, ray) and segment (endpoints), and that in the
Inscribed/Circumscribed example, some intermediary elements are
omitted from the final figure list and will not be displayed or
analyzed.

\begin{pdf-example}
[label=angle-bisector-distance]
{Angle Bisector Distance}
{images/angle-bisector-distance.pdf}
(define (angle-bisector-distance)
  (let-geo* (((a (r-1 v r-2)) (random-angle))
             (ab (angle-bisector a))
             (p (random-point-on-ray ab))
             ((s-1 (p b)) (perpendicular-to r-1 p))
             ((s-2 (p c)) (perpendicular-to r-2 p)))
     (figure a r-1 r-2 ab p s-1 s-2)))

=> (show-figure (angle-bisector-distance))
\end{pdf-example}

\begin{pdf-example}
[label=incircle-circumcircle-fig]
{Inscribed and Circumscribed Circles}
{images/incenter-circumcenter.pdf}
(define (inscribed-circumscribed)
  (let-geo* (((t (a b c)) (random-triangle))
             (((a-1 a-2 a-3)) (polygon-angles t))
             (ab1 (angle-bisector a-1))
             (ab2 (angle-bisector a-2))
             ((radius-segment (center-point radius-point))
              (perpendicular-to (make-segment a b)
                                (intersect-linear-elements ab1 ab2)))
             (incircle (circle-from-points
                        center-point
                        radius-point))
             (pb1 (perpendicular-bisector
                   (make-segment a b)))
             (pb2 (perpendicular-bisector
                   (make-segment b c)))
             (pb-center (intersect-lines pb1 pb2))
             (circum-cir (circle-from-points
                          pb-center
                          a)))
    (figure t a-1 a-2 a-3
            pb-center
            radius-segment
            incircle
            circum-cir)))

=> (show-figure (inscribed-circumscribed))
\end{pdf-example}

The sample images shown alongside these constructions represent images
from separate executions of the figure. An additional method for
viewing and displaying involves ``running an animation'' of these
constructions in which several instances of the figure are created and
displayed, incrementally wiggling each random choice. In generating
and wiggling the random values, some effort is taken to avoid
degenerate cases or instances where points are too close to one
another, as such cases lead to floating-point errors in the numerical
analysis.

\section{Perception and Observation}

Given the imperative construction module that enables the
specification and construction of geometry figures, the second module
focuses on perception and extracting interesting observations from
these figures.

Example \ref{simple-analysis} demonstrates the interface for obtaining
observations from a figure. An observation is a structure that
associates a relationship (concurrent, equal length, parallel) with
objects in the figure that satisfy the relationship. Relationships are
represented as predicates over typed n-tuples and are checked against
all such n-tuples found in the figure under analysis. For example, the
perpendicular relationship is checked against all pairs of linear elements
in the figure.

The observation objects are complex structures that maintain
properties of the underlying relationships and references to the
original objects under consideration. However, my custom printer
\texttt{print-observations} displays them in a more
human-readable format.

\begin{repl-example}
[label=simple-analysis]
{Simple Analysis}
=> (all-observations (triangle-with-perp-bisectors))

(#[observation 77] #[observation 78] #[observation 79] #[observation 80])

=> (print-observations (all-observations (triangle-with-perp-bisectors)))

((concurrent pb1 pb2 pb3)
 (perpendicular pb1 (segment a b))
 (perpendicular pb2 (segment b c))
 (perpendicular pb3 (segment c a)))
\end{repl-example}

The fact that the perpendicular bisector of a segment is equal to that
segment isn't very interesting. Thus, as shown in Example
\ref{interesting-analysis}, the analysis module also provides an
interface for reporting only the interesting observations. Currently,
information about the interesting relationships formed by a
perpendicular bisector are specified alongside instructions for how to
perform the operation, but a further extension of the learning module
could try to infer inductively which properties result from various
construction operations.

\begin{repl-example}
[label=interesting-analysis]
{Interesting Analysis}
=> (print-observations (interesting-observations
                         (triangle-with-perp-bisectors)))

((concurrent pb1 pb2 pb3))
\end{repl-example}

For an example with more relationships, Example
\ref{parallelogram-analysis} demonstrates the observations and
relationships found in a figure with a random parallelogram. These
analysis results will be used again later when we demonstrate the
system learning definitions for polygons. Note that although the
segments, angles, and points were not explicitly listed in the figure,
they are extracted from the polygon that is listed. Extensions to the
observation model can extract additional points and segments not
explicitly listed in the original figure.

\begin{repl-example}
[label=parallelogram-analysis]
{Parallelogram Analysis}
(define (parallelogram-figure)
  (let-geo* (((p (a b c d)) (random-parallelogram)))
    (figure p)))

=> (pprint (all-observations (parallelogram-figure)))

((equal-length (segment a b) (segment c d))
 (equal-length (segment b c) (segment d a))
 (equal-angle (angle a) (angle c))
 (equal-angle (angle b) (angle d))
 (supplementary (angle a) (angle b))
 (supplementary (angle a) (angle d))
 (supplementary (angle b) (angle c))
 (supplementary (angle c) (angle d))
 (parallel (segment a b) (segment c d))
 (parallel (segment b c) (segment d a)))
\end{repl-example}

\section{Mechanism-based Declarative Constraint Solver}

The first two modules focus on performing imperative constructions to
build diagrams and analyze them to obtain interesting symbolic
observations and relationships. Alone, these modules could assist a
mathematician in building, analyzing, and exploring geometry
concepts.

However, an important aspect of automating learning theorems and
definitions involves reversing this process and obtaining instances of
diagrams by solving provided symbolic constraints and
relationships. When we are told to ``Imagine a triangle ABC in which
AB = BC'', we visualize in our minds eye an instance of such a
triangle before continuing with the instructions.

Thus, the third module is a declarative constraint solver. To model
the physical concept of building and wiggling components until
constraints are satisfied, the system is formulated around solving
mechanisms built from bars and joints that must satisfy certain
constraints. Such constraint solving is implemented by extending the
Propagator Model created by Alexey Radul and Gerald Jay Sussman
[\ref{propagator-model}] to handle partial information and constraints
about geometry positions. Chapter~\ref{chap:declarative} discusses
further implementation details.

\subsection{Bars and Joints}

Example~\ref{simple-mechanism} demonstrates the specification of a
very simple mechanism. Mechanisms are created by specifying the bars
and joints involved as well as any additional constraints that must be
satisfied. This example mechanism is composed of two bars with one
joint between them that is constrained to be a right angle.

\begin{code-example}
[label=simple-mechanism]
{Very Simple Mechanism}
(define (simple-mechanism)
  (m:mechanism
   (m:make-named-bar 'a 'b)
   (m:make-named-bar 'b 'c)
   (m:make-named-joint 'a 'b 'c)
   (m:c-right-angle (m:joint 'b))))
\end{code-example}

Building a mechanism involves first assembling the bars and joints
together so that the named points are identified with one
another. Initially, each bar has unknown length and direction, each
joint has an unknown angle, and each endpoint has unknown
position. Constraints for the bar and joint properties are introduced
alongside any explicitly specified constraints.

Solving the mechanism involves repeatedly selecting position, lengths,
angles, and directions that are not fully specified and selecting
values within the domain of that value's current partial
information. As values are specified, the wiring of the propagator
model propagates further partial information to other values.

The printed statements in Example \ref{solving-simple-mechanism}
demonstrate that solving the simple mechanism above involves
specifying the location of point a, then specifying the length of bar
a-b and the direction from a that the bar extends. After those
specifications, the joint angle is constrained to be a right angle and
the location of point b is known by propagating information about
point a and bar a-b's position and length. Thus, the only remaining
property to fully specify the figure is the bar length of bar
b-c. After building and solving the mechanism, run-mechanism converts
it into a figure using the underlying primitives and displays it:

\begin{pdf-example}
[label=solving-simple-mechanism]
{Solving the Very Simple Mechanism}
{images/simple-mechanism.pdf}
=> (m:run-mechanism simple-mechanism)

(initializing-point m:bar:a:b-p1 (0 0))
(specifying-bar-length m:bar:a:b .5644024854677596)
(initializing-direction m:bar:a:b-dir (direction 4.999857164003272))
(specifying-bar-length m:bar:b:c 1.1507815910257295)
\end{pdf-example}

\subsection{Geometry Examples}

These bar and linkage mechanisms can be used to represent the
topologies of several geometry figures. Bars correspond to segments
and joints correspond to angles. Example \ref{arbitrary-tri}
demonstrates the set of linkages necessary to specify the topology of
a triangle.

\begin{code-example}
[label=arbitrary-tri]
{Describing an Arbitrary Triangle}
(define (arbitrary-triangle)
  (m:mechanism
   (m:make-named-bar 'a 'b)
   (m:make-named-bar 'b 'c)
   (m:make-named-bar 'c 'a)
   (m:make-named-joint 'a 'b 'c)
   (m:make-named-joint 'b 'c 'a)
   (m:make-named-joint 'c 'a 'b)))

(define (simpler-arbitrary-triangle)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c)))
\end{code-example}

When solving the mechanism

\begin{pdf-example}
[label=run-arbitrary-tri]
{Solving the Triangle}{images/arbitrary-triangle.pdf}
=> (m:run-mechanism (arbitrary-triangle))

(specifying-joint m:joint:c:b:a .41203408293499)
(initializing-direction m:joint:c:b:a-dir-1 (direction 3.888926311421853))
(specifying-joint m:joint:a:c:b 1.8745808264593105)
(initializing-point m:bar:c:a-p1 (0 0))
(specifying-bar-length m:bar:c:a .4027149730292784)
\end{pdf-example}


\begin{pdf-example}{Constraint Solving for Isoceles Triangle}
{images/isoceles.pdf}
(define (isoceles-triangle-by-angles)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c)
   (m:c-angle-equal (m:joint 'a)
                    (m:joint 'b))))

=> (m:run-mechanism  isoceles-triangle-by-angles)

(specifying-joint m:joint:c:b:a .6219719886662947)
(initializing-direction m:joint:c:b:a-dir-1 (direction .9330664240883363))
(initializing-point m:bar:b:c-p1 (0 0))
(specifying-bar-length m:bar:b:c .3557699722973674)
\end{pdf-example}

\begin{code-example}
{Rectangle Constraints Example}
(define (is-this-a-rectangle-2)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c 'd)
   (m:c-length-equal (m:bar 'a 'd)
                     (m:bar 'b 'c))
   (m:c-right-angle (m:joint 'd))
   (m:c-angle-equal (m:joint 'a)
                    (m:joint 'c))))
\end{code-example}

\begin{pdf-example}{Solved Constraints}{images/rect-demo.pdf}
=> (m:run-mechanism (is-this-a-rectangle-2))

(specifying-bar-length m:bar:d:a .6742252545577186)
(initializing-direction m:bar:d:a-dir (direction 4.382829365403101))
(initializing-point m:bar:d:a-p1 (0 0))
(specifying-joint m:joint:c:b:a 2.65583669872538)
\end{pdf-example}

\begin{pdf-example}{Constraint Solving for Parallelogram}
{images/parallelogram.pdf}
(define (parallelogram-by-angles)
  (m:mechanism
   (m:establish-polygon-topology 'a 'b 'c 'd)
   (m:c-angle-equal (m:joint 'a)
                    (m:joint 'c))
   (m:c-angle-equal (m:joint 'b)
                    (m:joint 'd))))

=> (m:run-mechanism parallelogram-by-angles)

(specifying-joint m:joint:c:b:a 1.6835699856637936)
(initializing-angle m:joint:c:b:a-dir-1 (direction 1.3978162819212452))
(initializing-point m:bar:a:b-p1 (0 0))
(specifying-bar-length m:bar:a:b .8152792207652096)
(specifying-bar-length m:bar:b:c .42887899934327023)
\end{pdf-example}

Finally, in addition to solving constraints of the angles and sides
for a single polygon, the mechanism system allows for the creation of
arbitrary topologies of bars and linkages.

\begin{code-example}{More Involved Topologies for Constraint Solving}
(define (m:quadrilateral-with-intersecting-diagonals a b c d e)
  (list (m:establish-polygon-topology a b e)
        (m:establish-polygon-topology b c e)
        (m:establish-polygon-topology c d e)
        (m:establish-polygon-topology d a e)
        (m:c-line-order c e a)
        (m:c-line-order b e d)))
\end{code-example}

\begin{pdf-example}
{Kites from Diagonal Properties}
{images/kite-diag.pdf}
(define (kite-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-right-angle (m:joint 'b 'e 'c)) ;; Right Angle in Center
   (m:c-length-equal (m:bar 'c 'e) (m:bar 'a 'e))))

=> (m:run-mechanism kite-from-diagonals)
\end{pdf-example}

\begin{pdf-example}
{Isoceles Trapezoids from Diagonals}
{images/it-diag.pdf}
(define (isoceles-trapezoid-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-length-equal (m:bar 'a 'e) (m:bar 'b 'e))
   (m:c-length-equal (m:bar 'c 'e) (m:bar 'd 'e))))

=> (m:run-mechanism isoceles-trapezoid-from-diagonals)
\end{pdf-example}

\begin{pdf-example}
{Parallelograms from Diagonal Properties}
{images/pl-diag.pdf}
(define (parallelogram-from-diagonals)
  (m:mechanism
   (m:quadrilateral-with-intersecting-diagonals 'a 'b 'c 'd 'e)
   (m:c-length-equal (m:bar 'a 'e) (m:bar 'c 'e))
   (m:c-length-equal (m:bar 'b 'e) (m:bar 'd 'e))))
\end{pdf-example}

\section{Learning Module}

Finally, given these modules for performing constructions, observing
interesting symbolic relationships, and rebuilding figures that
satisfy such relationship, a learning module interfaces with these
properties to emulate a student that is actively learning geometry.

A user representing the teacher can interact with the system by
querying what it knows, teaching it new terms, and asking it to apply
its knowledge to new situations.

\begin{repl-example}{Querying Terms}
=> (what-is 'trapezoid)
unknown

=> (what-is 'line)
primitive-definition

=> (what-is 'triangle)
(triangle (polygon)
          ((n-sides-3 identity)))
\end{repl-example}

\begin{pdf-example}
[comment style={frame hidden,opacityback=0,
raster columns=3,graphics pages={1,2,3}}]
{Random Figures}{images/rand-trp.pdf}
=> (show-element (random-trapezoid))
\end{pdf-example}

\begin{repl-example}
=> (pprint (analyze-element (random-trapezoid)))

((supplementary (angle a) (angle d))
 (supplementary (angle b) (angle c))
 (parallel (segment a b) (segment c d)))
\end{repl-example}

\begin{repl-example}
=> (learn-term 'pl random-parallelogram)
done

=> (what-is 'pl)
(pl
 (quadrilateral)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 2 3 <premise>))
  (equal-length (polygon-segment 1 2 <premise>)
                (polygon-segment 3 0 <premise>))
  (equal-angle (polygon-angle 0 <premise>)
               (polygon-angle 2 <premise>))
  (equal-angle (polygon-angle 1 <premise>)
               (polygon-angle 3 <premise>))
  (supplementary (polygon-angle 0 <premise>)
                 (polygon-angle 1 <premise>))
  (supplementary (polygon-angle 0 <premise>)
                 (polygon-angle 3 <premise>))
  (supplementary (polygon-angle 1 <premise>)
                 (polygon-angle 2 <premise>))
  (supplementary (polygon-angle 2 <premise>)
                 (polygon-angle 3 <premise>))
  (parallel (polygon-segment 0 1 <premise>)
            (polygon-segment 2 3 <premise>))
  (parallel (polygon-segment 1 2 <premise>)
            (polygon-segment 3 0 <premise>))))
\end{repl-example}

\begin{repl-example}{Testing Definitions}
=> (is-a? 'pl (random-parallelogram))
#t

=> (is-a? 'pl (random-rectangle))
#t

=> (is-a? 'pl (random-trapezoid))
(failed-conjecture
 (equal-length (polygon-segment 0 1 <premise>)
               (polygon-segment 2 3 <premise>)))

=> (is-a? 'pl (random-equilateral-triangle))
(failed-conjecture (n-sides-4 <premise>))
(failed-classification quadrilateral)

=> (is-a? 'pl (random-segment))
(failed-classification polygon)
(failed-classification quadrilateral)
\end{repl-example}

\begin{repl-example}{Building on Definitions}
=> (learn-term 'kite random-kite)
done

=> (learn-term 'rh random-rhombus)
done

=> (what-is 'rh)
(rh
 (pl kite)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 3 0 <premise>))
  (equal-length (polygon-segment 1 2 <premise>)
                (polygon-segment 2 3 <premise>))))

=> (learn-term 'rect random-rectangle)
done

=> (learn-term 'square random-square)
done

=> (what-is 'sq)
(sq (rh rectangle) ())
\end{repl-example}

\begin{repl-example}
{Learning Simple Definitions}

=> (what-is 'isoceles-triangle)

(i-t
 (triangle)
 ((equal-length (polygon-segment 0 1 <premise>)
                (polygon-segment 2 0 <premise>))
  (equal-angle (polygon-angle 1 <premise>) (polygon-angle 2 <premise>))))

=> (get-simple-definitions 'isoceles-triangle)

((invalid-definition ())
 (valid-definition
  ((equal-length (segment a b) (segment c a))))
 (valid-definition
  ((equal-angle (angle b) (angle c))))
 (valid-definition
  ((equal-length (segment a b) (segment c a))
   (equal-angle (angle b) (angle c)))))

=> (get-simple-definitions 'pl)

((invalid-definition ())
 (invalid-definition ((equal-length (segment a b) (segment c d))))
 (unknown-definition ((equal-length (segment b c) (segment d a))))
 (invalid-definition ((equal-angle (angle a) (angle c))))
 (invalid-definition ((equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-length (segment a b) (segment c d))
   (equal-length (segment b c) (segment d a))))
 (invalid-definition
  ((equal-length (segment b c) (segment d a))
   (equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-angle (angle a) (angle c))
   (equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-length (segment a b) (segment c d))
   (equal-length (segment b c) (segment d a))
   (equal-angle (angle a) (angle c))))
 (valid-definition
  ((equal-length (segment a b) (segment c d))
   (equal-length (segment b c) (segment d a))
   (equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-length (segment a b) (segment c d))
   (equal-angle (angle a) (angle c))
   (equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-length (segment b c) (segment d a))
   (equal-angle (angle a) (angle c))
   (equal-angle (angle b) (angle d))))
 (valid-definition
  ((equal-length (segment a b) (segment c d))
   (equal-length (segment b c) (segment d a))
   (equal-angle (angle a) (angle c))
   (equal-angle (angle b) (angle d)))))
\end{repl-example}
